// отступы и пробелы везде одинаковые и правила для них

ы            Task-1
// 1 -- ввод значений в структру

    /* основная функция - принять структура и сделать проверку на ввод там где int, double
    1.1 -- ввод заранее заданнаго количества стурктур(в начале спросить
    вы сколько полетов вы хотите занести в структуру и потом вводитьБ после 
    последней итерации спросить ввод закончен и предложить опять вводить )
    1.2 --если не знает сколько стурктур то принимать по 1 и спрашивать "хотите продолжить?"
    ***1.3 воодить пока не найдем структуру с определенным параметром
    */

// 2 -- вывод всех структур *пусть будет переменная которая зранит количество введенных

// 3 -- дополнить (в 1 уже есть такой функционал)

// 4 -- вывод номер рейсов которыые выдетаю(куда пользователь скажет) quick sort to upper (для номеров рейсов)

// 5 -- менять что-то в структуре(может и удалять)

// 6 --  quick sort to upper(для номеров рейсов) из 4 задания 


/*functions
1 - inputStruct
2 - outputStruct
3 - outputFlightNumber
    3.1  quick sort to upper(для номеров рейсов)
4 - correctingStruct
    4.1 deleteStruct
*/



### 1. Определение структуры
В этом пункте нужно создать структуру `Flight`, которая будет хранить информацию о каждом рейсе. Эта структура должна включать поля для номера рейса, типа самолета, пункта назначения и времени вылета. Поле `union` может быть использовано для хранения либо типа самолета в виде строки, либо в виде кода.

Пример:
```cpp
typedef struct {
    std::string flightNumber;
    union {
        std::string airplaneType;
        int airplaneTypeCode;
    };
    std::string destination;
    std::string departureTime;
} Flight;
```

### 2. Функция формирования массива
Здесь нужно реализовать функцию, которая будет создавать динамический массив структур и заполнять его значениями, введенными с клавиатуры. Эта функция должна иметь следующие возможности:
- Ввод заранее заданного количества структур.
- Ввод до появления структуры с заданным признаком (например, до введения рейса с определенным пунктом назначения).
- Диалог с пользователем о необходимости продолжать ввод данных.

### 3. Функция просмотра содержимого массива
Эта функция должна выводить на экран все структуры, находящиеся в массиве. Это поможет пользователю увидеть всю введенную информацию.

### 4. Функция дополнения массива
Эта функция позволяет добавлять новые структуры в уже существующий массив. Это важно для обновления информации по мере поступления новых данных.

### 5. Функция поиска и вывода
В этой функции реализуется поиск структур по заданному значению одного из полей (например, по пункту назначения). Результаты поиска должны выводиться на экран.

### 6. Функции удаления и изменения элементов
Эти функции предназначены для удаления или изменения структур в массиве. Они позволяют корректировать введенную информацию.

### 7. Функция сортировки
Эта функция выполняет сортировку массива структур по одному из полей (например, по времени вылета). В данном случае используем быструю сортировку (quick sort) для упорядочивания.

Пример функции сортировки:
```cpp
bool compareFlights(const Flight& a, const Flight& b) {
    return a.departureTime < b.departureTime;
}

void sortFlights(std::vector<Flight>& flights) {
    std::sort(flights.begin(), flights.end(), compareFlights);
}
```

### 8. Реализация меню
Создание меню для выбора и выполнения вышеописанных функций. Меню должно позволять пользователю выбирать, какую операцию выполнить: ввод данных, просмотр, поиск, сортировка и т.д.

### 9. Организация кода
Разделите программу на файлы `.h` и `.cpp` для улучшения читаемости и организации кода. Заголовочные файлы (.h) содержат определения структур и прототипы функций, а файлы реализации (.cpp) - реализацию этих функций.

### 10. Работа с двоичным файлом
Реализуйте функционал для работы с двоичным файлом, который позволит корректировать записи внутри файла без полной его перезаписи. Это включает в себя чтение и запись отдельных записей в файл.

Пример кода для обновления записи:
```cpp
void updateRecord(std::fstream& file, const Flight& flight, std::streampos pos) {
    file.seekp(pos);
    file.write(reinterpret_cast<const char*>(&flight), sizeof(Flight));
}
```

Этот план даёт детальное руководство по реализации задания. Если что-то требует дополнительного пояснения или есть конкретные вопросы, дайте знать!
